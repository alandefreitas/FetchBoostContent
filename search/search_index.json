{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CMake FetchContent for Boost libraries CMake FetchContent enables build scripts to download and populate the current project with a dependency at configure time. This feature does not work with Boost (sub-)libraries because of transitive dependencies and the way their CMake script rely on the main Boost project. The Boost libraries are widely useful and useful to most applications. A version of FetchContent that works for Boost libraries allows developers to (i) provide a fallback option when a Boost installation is not found locally, (ii) download only the required Boost (sub-)libraries required for a single project, (iii) experiment with single Boost libraries, and (iv) and facilitate cross-compiling with CMake. A subset of these features can only be obtained nowadays via package managers, which represent a different level of CMake integration, and does not automatically extend these benefits to end users not using the same package manager. This is a problem for library developers relying on Boost, since most end users still don't rely on package managers. This repository provides a version of FetchContent that works for Boost (sub-)libraries. When a library is populated, only its internal Boost dependencies are scanned and fetched. The functions are adapted to return or include all dependencies in their appropriate order without fetching the whole Boost super-project.","title":"Home"},{"location":"acknowledgments/","text":"Acknowledgments Contributors Alan De Freitas","title":"Acknowledgments"},{"location":"acknowledgments/#acknowledgments","text":"","title":"Acknowledgments"},{"location":"acknowledgments/#contributors","text":"Alan De Freitas","title":"Contributors"},{"location":"contributing/","text":"Guidelines \ud83d\udcd0 Discussions : Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If this library helps you create something interesting, please divulge it with the community. Sharing Ideas : If you are a programmer with good ideas, please share these ideas with us. PRs \ud83d\udca1 Feel free to contribute new features to this library. For complex features and changes, consider getting feedback from the community first. Contributing to an existing code base with its conventions might seem obscure at first but please don't let that discourage you from sharing your ideas. There are many ways in which you can contribute to this library: Testing the library in new environments see 1 , 2 , 3 Contributing with interesting examples see 1 Finding problems in this documentation see 1 Finding bugs in general see 1 , 2 , 3 , 4 Whatever idea seems interesting to you Constructive contributions The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature, so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative \"I removed this feature, so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first","title":"Contributing"},{"location":"contributing/#guidelines","text":"Discussions : Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If this library helps you create something interesting, please divulge it with the community. Sharing Ideas : If you are a programmer with good ideas, please share these ideas with us.","title":"Guidelines \ud83d\udcd0"},{"location":"contributing/#prs","text":"Feel free to contribute new features to this library. For complex features and changes, consider getting feedback from the community first. Contributing to an existing code base with its conventions might seem obscure at first but please don't let that discourage you from sharing your ideas. There are many ways in which you can contribute to this library: Testing the library in new environments see 1 , 2 , 3 Contributing with interesting examples see 1 Finding problems in this documentation see 1 Finding bugs in general see 1 , 2 , 3 , 4 Whatever idea seems interesting to you","title":"PRs \ud83d\udca1"},{"location":"contributing/#constructive-contributions","text":"The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature, so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative \"I removed this feature, so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first","title":"Constructive contributions"},{"location":"declare/","text":"FetchBoostContent_Declare Boost modules FetchBoostContent_Declare is the Boost analogous of FetchContent_Declare . The function also accepts the same arguments as FetchContent_Declare . Declare content FetchBoostContent_Declare ( boost_beast GIT_REPOSITORY https://github.com/boostorg/beast GIT_TAG master ) Note The module name always needs to start with \"boost_\" The declare function stores details about the Boost module and calls the regular FetchContent_Declare function for the module. These properties need to be later retrieved by other functions. The implementation ensures only the first declaration is used when populating the library. Note that FetchContent is often used in conjunction with find_package , where the library is declared and fetched only when not available in the system: Find package or fetch find_package ( Boost COMPONENTS container ) if ( NOT Boost_FOUND ) include ( cmake/FetchBoostContent.cmake ) # Example fetching Boost.Beast FetchBoostContent_Declare ( boost_beast GIT_REPOSITORY https://github.com/boostorg/beast GIT_TAG master ) # fetch library...","title":"Declare"},{"location":"declare/#fetchboostcontent_declare","text":"","title":"FetchBoostContent_Declare"},{"location":"declare/#boost-modules","text":"FetchBoostContent_Declare is the Boost analogous of FetchContent_Declare . The function also accepts the same arguments as FetchContent_Declare . Declare content FetchBoostContent_Declare ( boost_beast GIT_REPOSITORY https://github.com/boostorg/beast GIT_TAG master ) Note The module name always needs to start with \"boost_\" The declare function stores details about the Boost module and calls the regular FetchContent_Declare function for the module. These properties need to be later retrieved by other functions. The implementation ensures only the first declaration is used when populating the library. Note that FetchContent is often used in conjunction with find_package , where the library is declared and fetched only when not available in the system: Find package or fetch find_package ( Boost COMPONENTS container ) if ( NOT Boost_FOUND ) include ( cmake/FetchBoostContent.cmake ) # Example fetching Boost.Beast FetchBoostContent_Declare ( boost_beast GIT_REPOSITORY https://github.com/boostorg/beast GIT_TAG master ) # fetch library...","title":"Boost modules"},{"location":"linking/","text":"Linking targets The strategy to link libraries depend on how they have been fetched. Header-only libraries Boost header-only libraries can be linked with the Boost::headers interface target: Linking interface target for all headers add_executable ( http-client-sync http-client-sync.cpp ) target_link_libraries ( http-client-sync Boost::headers ) The advantage of the interface target Boost::headers is that find_package(Boost) also provides this target, so that the \"find-or-fetch\" pattern works transparently. Find package or fetch find_package ( Boost COMPONENTS container ) if ( NOT Boost_FOUND ) include ( cmake/FetchBoostContent.cmake ) # Example fetching Boost.Beast FetchBoostContent_Declare ( boost_beast GIT_REPOSITORY https://github.com/boostorg/beast GIT_TAG master ) # fetch library... This assumes the library was integrated with FetchBoostContent_MakeAvailable or the interface target was created manually with a pattern such as Source directory include directories # Create an interface target for all the include dirs add_library ( boost_headers INTERFACE ) add_library ( Boost::headers ALIAS boost_headers ) # <library>_SOURCE_DIRS contains the source dir for all <library> dependencies foreach ( dir ${ boost_beast_SOURCE_DIRS } ) target_include_directories ( boost_headers INTERFACE ${ dir } /include ) endforeach () Individual interface targets Header-only modules also provide interface targets representing a single library in their build script. _conditional Linking interface target if ( NOT Boost_FOUND ) add_executable ( circular_buffer circular_buffer.cpp ) target_link_libraries ( circular_buffer Boost::circular_buffer ) This assumes the library was integrated with FetchBoostContent_MakeAvailable or the module targets were created manually by including their subdirectories: Declare and make available as target Adding subdirectories for all dependencies FetchBoostContent_Declare ( boost_circular_buffer GIT_REPOSITORY https://github.com/boostorg/circular_buffer GIT_TAG master ) FetchBoostContent_MakeAvailable ( boost_circular_buffer ) FetchBoostContent_Populate ( boost_container ) foreach ( dir ${ boost_container_SOURCE_DIRS } ) add_subdirectory ( ${ dir } ) endforeach () The advantage of these targets is that only include the directories required for a given target are associated with the executable. However, note that the integration script used by find_package(Boost) is not generated with the usual CMake facilities to export targets. Thus, not all targets available from module CMake build scripts are also provided with find_package(Boost) . In this case, we need special treatment for the case when find_package(Boost) has been used. Compiled libraries Targets are provided for modules that require building and linking: Linking a compiled target add_executable ( container container.cpp ) target_link_libraries ( container Boost::container ) This also assumes the library was integrated with FetchBoostContent_MakeAvailable or the module targets were created manually by including their subdirectories. Otherwise, a customized script should be provided to build these modules. The advantage of targets such as Boost::<module> is that find_package(Boost COMPONENTS <modules>) also provides this target, so that the \"find-or-fetch\" pattern works transparently. Summary When fetching libraries, we usually want to build the libraries as if find_package(Boost) was being used. This allows us to use the targets in such a way that they can be linked transparently, without special treatment for each of the integration methods. In practice, this means we should generate the Boost::headers and Boost::<module> targets. Boost::headers includes all libraries and Boost::<module> represent individual compiled libraries. To achieve this, we can usually import the libraries with the following relationship between the strategies presented above: Use find_package with the required COMPONENTS when possible. Importing a Boost installation is faster than fetching and building all modules. Use FetchBoostContent_MakeAvailable when possible. This creates compatible targets for header-only ( Boost::headers ) and compiled libraries ( Boost::<module> ). Use FetchBoostContent_MakeAvailable for the library dependencies when possible so that not all libraries have to be included manually. Add the library include directories to the Boost::headers target when creating targets manually.","title":"Linking"},{"location":"linking/#linking-targets","text":"The strategy to link libraries depend on how they have been fetched.","title":"Linking targets"},{"location":"linking/#header-only-libraries","text":"Boost header-only libraries can be linked with the Boost::headers interface target: Linking interface target for all headers add_executable ( http-client-sync http-client-sync.cpp ) target_link_libraries ( http-client-sync Boost::headers ) The advantage of the interface target Boost::headers is that find_package(Boost) also provides this target, so that the \"find-or-fetch\" pattern works transparently. Find package or fetch find_package ( Boost COMPONENTS container ) if ( NOT Boost_FOUND ) include ( cmake/FetchBoostContent.cmake ) # Example fetching Boost.Beast FetchBoostContent_Declare ( boost_beast GIT_REPOSITORY https://github.com/boostorg/beast GIT_TAG master ) # fetch library... This assumes the library was integrated with FetchBoostContent_MakeAvailable or the interface target was created manually with a pattern such as Source directory include directories # Create an interface target for all the include dirs add_library ( boost_headers INTERFACE ) add_library ( Boost::headers ALIAS boost_headers ) # <library>_SOURCE_DIRS contains the source dir for all <library> dependencies foreach ( dir ${ boost_beast_SOURCE_DIRS } ) target_include_directories ( boost_headers INTERFACE ${ dir } /include ) endforeach ()","title":"Header-only libraries"},{"location":"linking/#individual-interface-targets","text":"Header-only modules also provide interface targets representing a single library in their build script. _conditional Linking interface target if ( NOT Boost_FOUND ) add_executable ( circular_buffer circular_buffer.cpp ) target_link_libraries ( circular_buffer Boost::circular_buffer ) This assumes the library was integrated with FetchBoostContent_MakeAvailable or the module targets were created manually by including their subdirectories: Declare and make available as target Adding subdirectories for all dependencies FetchBoostContent_Declare ( boost_circular_buffer GIT_REPOSITORY https://github.com/boostorg/circular_buffer GIT_TAG master ) FetchBoostContent_MakeAvailable ( boost_circular_buffer ) FetchBoostContent_Populate ( boost_container ) foreach ( dir ${ boost_container_SOURCE_DIRS } ) add_subdirectory ( ${ dir } ) endforeach () The advantage of these targets is that only include the directories required for a given target are associated with the executable. However, note that the integration script used by find_package(Boost) is not generated with the usual CMake facilities to export targets. Thus, not all targets available from module CMake build scripts are also provided with find_package(Boost) . In this case, we need special treatment for the case when find_package(Boost) has been used.","title":"Individual interface targets"},{"location":"linking/#compiled-libraries","text":"Targets are provided for modules that require building and linking: Linking a compiled target add_executable ( container container.cpp ) target_link_libraries ( container Boost::container ) This also assumes the library was integrated with FetchBoostContent_MakeAvailable or the module targets were created manually by including their subdirectories. Otherwise, a customized script should be provided to build these modules. The advantage of targets such as Boost::<module> is that find_package(Boost COMPONENTS <modules>) also provides this target, so that the \"find-or-fetch\" pattern works transparently.","title":"Compiled libraries"},{"location":"linking/#summary","text":"When fetching libraries, we usually want to build the libraries as if find_package(Boost) was being used. This allows us to use the targets in such a way that they can be linked transparently, without special treatment for each of the integration methods. In practice, this means we should generate the Boost::headers and Boost::<module> targets. Boost::headers includes all libraries and Boost::<module> represent individual compiled libraries. To achieve this, we can usually import the libraries with the following relationship between the strategies presented above: Use find_package with the required COMPONENTS when possible. Importing a Boost installation is faster than fetching and building all modules. Use FetchBoostContent_MakeAvailable when possible. This creates compatible targets for header-only ( Boost::headers ) and compiled libraries ( Boost::<module> ). Use FetchBoostContent_MakeAvailable for the library dependencies when possible so that not all libraries have to be included manually. Add the library include directories to the Boost::headers target when creating targets manually.","title":"Summary"},{"location":"make_available/","text":"FetchBoostContent_MakeAvailable Fetching modules FetchBoostContent_MakeAvailable is the Boost analogous of FetchContent_MakeAvailable . The function can be used to simplify the pattern to create library targets into only 2 steps: Declare and make available as target FetchBoostContent_Declare ( boost_circular_buffer GIT_REPOSITORY https://github.com/boostorg/circular_buffer GIT_TAG master ) FetchBoostContent_MakeAvailable ( boost_circular_buffer ) FetchBoostContent_MakeAvailable will include the library with a procedure similar to common pattern of adding subdirectories. Thus, it is roughly equivalent to: The pattern of make available FetchBoostContent_GetProperties ( boost_container ) if ( NOT boost_container_POPULATED ) FetchBoostContent_Populate ( boost_container ) foreach ( dir ${ boost_container_SOURCE_DIRS } ) add_subdirectory ( ${ dir } ) endforeach () endif () Note how FetchBoostContent_MakeAvailable cannot be replaced with FetchContent_MakeAvailable , which will only add the main module. FetchBoostContent_MakeAvailable is recommendable over the pattern above because it also takes care of a few details might go wrong in the pattern above, such as: Not including subdirectories that have already been included with FetchBoostContent_MakeAvailable Not including subdirectories for modules whose targets have already been defined Not including subdirectories for modules without a CMakeLists.txt file Adding the include module subdirectory to the Boost::headers target even if a CMakeLists.txt file isn't available Create the Boost::headers target if one doesn't exist yet Adding the include directories to the Boost::headers target only if it's not an imported target This is especially important when more than one Boost module will be included in the same project, as they will depend on a dependency intersection of modules that will attempt to add the same subdirectory twice. As with FetchBoostContent_Populate , this pattern assumes the libraries can be integrated with add_subdirectory or are header-only. A special pattern might be required for a dependency that doesn't meet this criteria.","title":"MakeAvailable"},{"location":"make_available/#fetchboostcontent_makeavailable","text":"","title":"FetchBoostContent_MakeAvailable"},{"location":"make_available/#fetching-modules","text":"FetchBoostContent_MakeAvailable is the Boost analogous of FetchContent_MakeAvailable . The function can be used to simplify the pattern to create library targets into only 2 steps: Declare and make available as target FetchBoostContent_Declare ( boost_circular_buffer GIT_REPOSITORY https://github.com/boostorg/circular_buffer GIT_TAG master ) FetchBoostContent_MakeAvailable ( boost_circular_buffer ) FetchBoostContent_MakeAvailable will include the library with a procedure similar to common pattern of adding subdirectories. Thus, it is roughly equivalent to: The pattern of make available FetchBoostContent_GetProperties ( boost_container ) if ( NOT boost_container_POPULATED ) FetchBoostContent_Populate ( boost_container ) foreach ( dir ${ boost_container_SOURCE_DIRS } ) add_subdirectory ( ${ dir } ) endforeach () endif () Note how FetchBoostContent_MakeAvailable cannot be replaced with FetchContent_MakeAvailable , which will only add the main module. FetchBoostContent_MakeAvailable is recommendable over the pattern above because it also takes care of a few details might go wrong in the pattern above, such as: Not including subdirectories that have already been included with FetchBoostContent_MakeAvailable Not including subdirectories for modules whose targets have already been defined Not including subdirectories for modules without a CMakeLists.txt file Adding the include module subdirectory to the Boost::headers target even if a CMakeLists.txt file isn't available Create the Boost::headers target if one doesn't exist yet Adding the include directories to the Boost::headers target only if it's not an imported target This is especially important when more than one Boost module will be included in the same project, as they will depend on a dependency intersection of modules that will attempt to add the same subdirectory twice. As with FetchBoostContent_Populate , this pattern assumes the libraries can be integrated with add_subdirectory or are header-only. A special pattern might be required for a dependency that doesn't meet this criteria.","title":"Fetching modules"},{"location":"options/","text":"Options The following CMake variables can be set before calling FetchBoostContent_Populate to influence its behaviour: Option Default Description Logging FETCH_BOOST_CONTENT_VERBOSE 0 Verbose output level FETCH_BOOST_CONTENT_QUIET OFF quiet output Directories FETCH_BOOST_CONTENT_INCLUDE \"\" additional subdirectoroes to scan FETCH_BOOST_CONTENT_EXCLUDE \"\" exclude a default subdirectory (\"include\", \"src\") from scan Behavior FETCH_BOOST_CONTENT_PRUNE_DEPENDENCIES OFF prune transitive dependencies on which library doesn't depend FETCH_BOOST_CONTENT_IGNORE_CACHE OFF ignore cached dependency list (rescan files every time) FETCH_BOOST_CONTENT_IGNORE \"\" exclude top-level dependency even when found in scan The FETCH_BOOST_CONTENT_PRUNE_DEPENDENCIES option will prune any transitive header-only dependencies on which the main library does not rely. For instance, considering these header-only libraries: A: boost/a/a1.hpp includes boost/b/b1.hpp includes boost/b/b2.hpp B: boost/b/b1.hpp includes boost/c/c1.hpp includes boost/c/c2.hpp boost/b/b2.hpp C: boost/c/c1.hpp boost/c/c2.hpp boost/c/c3.hpp includes boost/d/d1.hpp D: boost/d/d1.hpp When FETCH_BOOST_CONTENT_PRUNE_DEPENDENCIES is OFF, this would fetch the libraries A, B, C, and D, because of the transitive relationship A -> B -> C -> D. When FETCH_BOOST_CONTENT_PRUNE_DEPENDENCIES is ON, this would only fetch the libraries A, B, and C, because fetching the dependency D for the transitive relationship C -> D is only required when A is indirectly using boost/c/c3.hpp . Pruning makes the process of fetching faster. This is particularly useful when a given library happens to be at a high dependency level only for requiring a smaller feature from a library with many other transitive dependencies. However, the scripts in C might depend on targets created by D. In this case, we cannot include C with add_subdirectory . This is usually not a problem, as long as the libraries are header-only, as we can just use Boost::headers . For compiled libraries, it's often easier to use add_subdirectory .","title":"Options"},{"location":"options/#options","text":"The following CMake variables can be set before calling FetchBoostContent_Populate to influence its behaviour: Option Default Description Logging FETCH_BOOST_CONTENT_VERBOSE 0 Verbose output level FETCH_BOOST_CONTENT_QUIET OFF quiet output Directories FETCH_BOOST_CONTENT_INCLUDE \"\" additional subdirectoroes to scan FETCH_BOOST_CONTENT_EXCLUDE \"\" exclude a default subdirectory (\"include\", \"src\") from scan Behavior FETCH_BOOST_CONTENT_PRUNE_DEPENDENCIES OFF prune transitive dependencies on which library doesn't depend FETCH_BOOST_CONTENT_IGNORE_CACHE OFF ignore cached dependency list (rescan files every time) FETCH_BOOST_CONTENT_IGNORE \"\" exclude top-level dependency even when found in scan The FETCH_BOOST_CONTENT_PRUNE_DEPENDENCIES option will prune any transitive header-only dependencies on which the main library does not rely. For instance, considering these header-only libraries: A: boost/a/a1.hpp includes boost/b/b1.hpp includes boost/b/b2.hpp B: boost/b/b1.hpp includes boost/c/c1.hpp includes boost/c/c2.hpp boost/b/b2.hpp C: boost/c/c1.hpp boost/c/c2.hpp boost/c/c3.hpp includes boost/d/d1.hpp D: boost/d/d1.hpp When FETCH_BOOST_CONTENT_PRUNE_DEPENDENCIES is OFF, this would fetch the libraries A, B, C, and D, because of the transitive relationship A -> B -> C -> D. When FETCH_BOOST_CONTENT_PRUNE_DEPENDENCIES is ON, this would only fetch the libraries A, B, and C, because fetching the dependency D for the transitive relationship C -> D is only required when A is indirectly using boost/c/c3.hpp . Pruning makes the process of fetching faster. This is particularly useful when a given library happens to be at a high dependency level only for requiring a smaller feature from a library with many other transitive dependencies. However, the scripts in C might depend on targets created by D. In this case, we cannot include C with add_subdirectory . This is usually not a problem, as long as the libraries are header-only, as we can just use Boost::headers . For compiled libraries, it's often easier to use add_subdirectory .","title":"Options"},{"location":"populate/","text":"FetchBoostContent_Populate Fetching modules FetchBoostContent_Populate is the Boost analogous of FetchContent_Populate . The function also accepts the same arguments as FetchContent_Populate . Declare content # Check if population has already been performed FetchBoostContent_GetProperties ( boost_beast ) if ( NOT boost_beast_POPULATED ) # Fetch the content using previously declared details FetchBoostContent_Populate ( boost_beast ) The process usually starts with a call to FetchBoostContent_GetProperties . This first function is used to get properties about a module already declared with FetchBoostContent_Declare . In practice, this pattern is used to obtain <module>_boost_beast_POPULATED so we know whether this library has already been fetched. If the library has not been fetched yet ( NOT <library>_POPULATED ), we proceed with FetchBoostContent_Populate to finally fetch the library. This will initially invoke FetchContent_Populate for the main module and then fetch all of its dependencies. Procedure At this point, the usual FetchContent_Populate would be done. For Boost libraries,we still need to identify, declare and populate dependencies. FetchBoostContent_Populate achieves that with a logic similar to that of Boost.Boostdep : The library source and header files are scanned only for other internal boost dependencies. The dependencies are sorted by their level. Only the undeclared modules are declared and fetched as required Transitive dependencies are scanned recursively as required All dependencies are sorted by their transitive level The libraries are only scanned the first time they are fetched. The dependency results are cached in the subdirectories for subsequent executions. Results As FetchContent_Populate , FetchBoostContent_Populate will set the variables <library>_SOURCE_DIR and <library>_BINARY_DIR on the parent scope. However, FetchBoostContent_Populate will also set: <library>_DEPS : list of all transitive dependencies <library>_SOURCE_DIRS : source directory of all transitive dependencies <library>_BINARY_DIRS : binary directory of all transitive dependencies Creating targets All of these results are sorted by their transitive dependency level in such a way that their subdirectories can be included in order. Adding subdirectories for all dependencies FetchBoostContent_Populate ( boost_container ) foreach ( dir ${ boost_container_SOURCE_DIRS } ) add_subdirectory ( ${ dir } ) endforeach () This pattern assumes all libraries can be integrated with add_subdirectory , which is usually the case when the dependencies are included in order. Header-only libraries The add_subdirectory pattern might not work if some dependencies don't have a build script and have a script with bugs, such as attempting to link a target that is not a dependency, thus relying on a dependency that won't be fetched. This more likely to fail in a module at a high dependency level . In these cases, especially when we only depend on header-only libraries, an easy solution is to create an INTERFACE target for all header files: Source directory include directories # Create an interface target for all the include dirs add_library ( boost_headers INTERFACE ) add_library ( Boost::headers ALIAS boost_headers ) # <library>_SOURCE_DIRS contains the source dir for all <library> dependencies foreach ( dir ${ boost_beast_SOURCE_DIRS } ) target_include_directories ( boost_headers INTERFACE ${ dir } /include ) endforeach () The name Boost::headers is used to make it compatible with the IMPORTED target created by find_package (Boost) . Boost Library Proposals In general, Boost library proposals can be fetched with the same pattern as any other Boost library. FetchBoostContent_Populate will look for its dependencies as it would with any other Boost library. However, fetching Boost library proposals with the \"find-or-fetch\" pattern might require a different logic, depending on how their scripts are defined. We have a number of potential problems here: find_package might find Boost, in which case we don't need to fetch the Boost dependencies, but we still need to fetch the proposed library. FetchBoostContent_Populate will attempt to fetch dependencies, while find_package already found the modules we need. We cannot adjust Boost::headers with both dependencies, because it might be now an IMPORTED target. The proposed library assumes it's a subdirectory of the Boost super-project. The build script might not be ready to assume other dependencies could come from find_package . This means we might need a different logic depending on whether Boost was found with find_package . For this reason, FetchBoostContent_Populate will not fetch the module dependencies if Boost_FOUND is defined in the parent scope: # Fetch the content and maybe the dependencies FetchBoostContent_Populate ( boost_url ) When Boost is found with find_package ( if (Boost_FOUND) ) we will have fetched the library without its dependencies and create a second interface target for the imported Boost headers and the library headers: # Create an interface target for boost + url headers add_library ( url_headers INTERFACE ) target_link_libraries ( url_headers INTERFACE Boost::headers ) target_include_directories ( url_headers INTERFACE ${ boost_url_SOURCE_DIR } /include ) This second target can also be used to include any compilation step required by the library. When Boost is not found with find_package ( if (Boost_FOUND) ) we fetch the library as usual with its dependencies. # Add all dependencies to Boost::headers, including Boost.URL if ( NOT TARGET boost_headers ) add_library ( boost_headers INTERFACE ) endif () foreach ( dir ${ boost_url_SOURCE_DIRS } ) target_include_directories ( boost_headers INTERFACE ${ dir } /include ) endforeach () We can also create a convenience interface target for the Boost and library targets, which should now be all be defined in Boost::headers . # Create a url_headers target for boost + url to simplify linking add_library ( url_headers INTERFACE ) target_link_libraries ( url_headers INTERFACE Boost::headers ) The convenience target allows us to reuse the same logic when linking to the library: Linking convenience target for Boost proposal libs add_executable ( parse_url parse_url.cpp ) target_link_libraries ( parse_url PRIVATE url_headers ) This can be ignored if the library has a build script that handles integration as Boost sub_directories, as other projects' sub_directories, and as a standalone project.","title":"Populate"},{"location":"populate/#fetchboostcontent_populate","text":"","title":"FetchBoostContent_Populate"},{"location":"populate/#fetching-modules","text":"FetchBoostContent_Populate is the Boost analogous of FetchContent_Populate . The function also accepts the same arguments as FetchContent_Populate . Declare content # Check if population has already been performed FetchBoostContent_GetProperties ( boost_beast ) if ( NOT boost_beast_POPULATED ) # Fetch the content using previously declared details FetchBoostContent_Populate ( boost_beast ) The process usually starts with a call to FetchBoostContent_GetProperties . This first function is used to get properties about a module already declared with FetchBoostContent_Declare . In practice, this pattern is used to obtain <module>_boost_beast_POPULATED so we know whether this library has already been fetched. If the library has not been fetched yet ( NOT <library>_POPULATED ), we proceed with FetchBoostContent_Populate to finally fetch the library. This will initially invoke FetchContent_Populate for the main module and then fetch all of its dependencies.","title":"Fetching modules"},{"location":"populate/#procedure","text":"At this point, the usual FetchContent_Populate would be done. For Boost libraries,we still need to identify, declare and populate dependencies. FetchBoostContent_Populate achieves that with a logic similar to that of Boost.Boostdep : The library source and header files are scanned only for other internal boost dependencies. The dependencies are sorted by their level. Only the undeclared modules are declared and fetched as required Transitive dependencies are scanned recursively as required All dependencies are sorted by their transitive level The libraries are only scanned the first time they are fetched. The dependency results are cached in the subdirectories for subsequent executions.","title":"Procedure"},{"location":"populate/#results","text":"As FetchContent_Populate , FetchBoostContent_Populate will set the variables <library>_SOURCE_DIR and <library>_BINARY_DIR on the parent scope. However, FetchBoostContent_Populate will also set: <library>_DEPS : list of all transitive dependencies <library>_SOURCE_DIRS : source directory of all transitive dependencies <library>_BINARY_DIRS : binary directory of all transitive dependencies","title":"Results"},{"location":"populate/#creating-targets","text":"All of these results are sorted by their transitive dependency level in such a way that their subdirectories can be included in order. Adding subdirectories for all dependencies FetchBoostContent_Populate ( boost_container ) foreach ( dir ${ boost_container_SOURCE_DIRS } ) add_subdirectory ( ${ dir } ) endforeach () This pattern assumes all libraries can be integrated with add_subdirectory , which is usually the case when the dependencies are included in order.","title":"Creating targets"},{"location":"populate/#header-only-libraries","text":"The add_subdirectory pattern might not work if some dependencies don't have a build script and have a script with bugs, such as attempting to link a target that is not a dependency, thus relying on a dependency that won't be fetched. This more likely to fail in a module at a high dependency level . In these cases, especially when we only depend on header-only libraries, an easy solution is to create an INTERFACE target for all header files: Source directory include directories # Create an interface target for all the include dirs add_library ( boost_headers INTERFACE ) add_library ( Boost::headers ALIAS boost_headers ) # <library>_SOURCE_DIRS contains the source dir for all <library> dependencies foreach ( dir ${ boost_beast_SOURCE_DIRS } ) target_include_directories ( boost_headers INTERFACE ${ dir } /include ) endforeach () The name Boost::headers is used to make it compatible with the IMPORTED target created by find_package (Boost) .","title":"Header-only libraries"},{"location":"populate/#boost-library-proposals","text":"In general, Boost library proposals can be fetched with the same pattern as any other Boost library. FetchBoostContent_Populate will look for its dependencies as it would with any other Boost library. However, fetching Boost library proposals with the \"find-or-fetch\" pattern might require a different logic, depending on how their scripts are defined. We have a number of potential problems here: find_package might find Boost, in which case we don't need to fetch the Boost dependencies, but we still need to fetch the proposed library. FetchBoostContent_Populate will attempt to fetch dependencies, while find_package already found the modules we need. We cannot adjust Boost::headers with both dependencies, because it might be now an IMPORTED target. The proposed library assumes it's a subdirectory of the Boost super-project. The build script might not be ready to assume other dependencies could come from find_package . This means we might need a different logic depending on whether Boost was found with find_package . For this reason, FetchBoostContent_Populate will not fetch the module dependencies if Boost_FOUND is defined in the parent scope: # Fetch the content and maybe the dependencies FetchBoostContent_Populate ( boost_url ) When Boost is found with find_package ( if (Boost_FOUND) ) we will have fetched the library without its dependencies and create a second interface target for the imported Boost headers and the library headers: # Create an interface target for boost + url headers add_library ( url_headers INTERFACE ) target_link_libraries ( url_headers INTERFACE Boost::headers ) target_include_directories ( url_headers INTERFACE ${ boost_url_SOURCE_DIR } /include ) This second target can also be used to include any compilation step required by the library. When Boost is not found with find_package ( if (Boost_FOUND) ) we fetch the library as usual with its dependencies. # Add all dependencies to Boost::headers, including Boost.URL if ( NOT TARGET boost_headers ) add_library ( boost_headers INTERFACE ) endif () foreach ( dir ${ boost_url_SOURCE_DIRS } ) target_include_directories ( boost_headers INTERFACE ${ dir } /include ) endforeach () We can also create a convenience interface target for the Boost and library targets, which should now be all be defined in Boost::headers . # Create a url_headers target for boost + url to simplify linking add_library ( url_headers INTERFACE ) target_link_libraries ( url_headers INTERFACE Boost::headers ) The convenience target allows us to reuse the same logic when linking to the library: Linking convenience target for Boost proposal libs add_executable ( parse_url parse_url.cpp ) target_link_libraries ( parse_url PRIVATE url_headers ) This can be ignored if the library has a build script that handles integration as Boost sub_directories, as other projects' sub_directories, and as a standalone project.","title":"Boost Library Proposals"},{"location":"proposals/","text":"FetchBoostContent_Declare Boost library proposals FetchBoostContent_Declare is particularly useful to experiment with Boost library proposals. Declare Boost.URL proposal repo Declare Boost.MySQL proposal repo FetchBoostContent_Declare ( boost_url # repository outside boostorg: GIT_REPOSITORY https://github.com/CPPAlliance/url GIT_TAG master ) FetchBoostContent_Declare ( boost_mysql # repository outside boostorg: GIT_REPOSITORY https://github.com/anarthal/mysql GIT_TAG master ) Boost proposals are often very hard to integrate. Their CMake build scripts assume: the module is part of the build distribution and usually contain no scripts for installing the library. This means the library will work with neither with find_package nor with FetchContent . The only alternatives are: to install a patched version of Boost on the system or to rewrite the build script for these libraries locally. It's easy to see how this could be inconvenient. FetchBoostContent makes integration much easier because the modules will be considered a regular Boost sub-library whose dependencies will also be fetched.","title":"Proposals"},{"location":"proposals/#fetchboostcontent_declare","text":"","title":"FetchBoostContent_Declare"},{"location":"proposals/#boost-library-proposals","text":"FetchBoostContent_Declare is particularly useful to experiment with Boost library proposals. Declare Boost.URL proposal repo Declare Boost.MySQL proposal repo FetchBoostContent_Declare ( boost_url # repository outside boostorg: GIT_REPOSITORY https://github.com/CPPAlliance/url GIT_TAG master ) FetchBoostContent_Declare ( boost_mysql # repository outside boostorg: GIT_REPOSITORY https://github.com/anarthal/mysql GIT_TAG master ) Boost proposals are often very hard to integrate. Their CMake build scripts assume: the module is part of the build distribution and usually contain no scripts for installing the library. This means the library will work with neither with find_package nor with FetchContent . The only alternatives are: to install a patched version of Boost on the system or to rewrite the build script for these libraries locally. It's easy to see how this could be inconvenient. FetchBoostContent makes integration much easier because the modules will be considered a regular Boost sub-library whose dependencies will also be fetched.","title":"Boost library proposals"},{"location":"quickstart/","text":"Quickstart Integration \ud83d\udcbb Downloading Download with CMake You can copy the script from our repository in cmake/FetchBoostContent.cmake or the release page , and include it in your project. include ( cmake/FetchBoostContent.cmake ) When FetchContent is not going to be the main strategy for integrating Boost, a second alternative is to use CMake itself to download the script file and include it only when needed. if ( USE_FETCH_CONTENT ) set ( url https://github.com/alandefreitas/FetchBoostContent/blob/master/cmake/FetchBoostContent.cmake ) set ( destination ${ CMAKE_CURRENT_BINARY_DIR } /cmake/FetchBoostContent.cmake} ) if ( NOT EXISTS destination ) file ( DOWNLOAD ${ url } ${ destination } ) endif () include ( ${ destination } ) endif () This strategy might also be useful to keep the script up-to-date. Hello world \ud83d\udc4b Including the script include ( cmake/FetchBoostContent.cmake ) Declare and make available as target FetchBoostContent_Declare ( boost_circular_buffer GIT_REPOSITORY https://github.com/boostorg/circular_buffer GIT_TAG master ) FetchBoostContent_MakeAvailable ( boost_circular_buffer ) Declare content FetchBoostContent_Declare ( boost_beast GIT_REPOSITORY https://github.com/boostorg/beast GIT_TAG master ) Declare content # Check if population has already been performed FetchBoostContent_GetProperties ( boost_beast ) if ( NOT boost_beast_POPULATED ) # Fetch the content using previously declared details FetchBoostContent_Populate ( boost_beast ) Source directory include directories # Create an interface target for all the include dirs add_library ( boost_headers INTERFACE ) add_library ( Boost::headers ALIAS boost_headers ) # <library>_SOURCE_DIRS contains the source dir for all <library> dependencies foreach ( dir ${ boost_beast_SOURCE_DIRS } ) target_include_directories ( boost_headers INTERFACE ${ dir } /include ) endforeach () Linking interface target for all headers add_executable ( http-client-sync http-client-sync.cpp ) target_link_libraries ( http-client-sync Boost::headers ) Linking a compiled target add_executable ( container container.cpp ) target_link_libraries ( container Boost::container )","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#integration","text":"Downloading Download with CMake You can copy the script from our repository in cmake/FetchBoostContent.cmake or the release page , and include it in your project. include ( cmake/FetchBoostContent.cmake ) When FetchContent is not going to be the main strategy for integrating Boost, a second alternative is to use CMake itself to download the script file and include it only when needed. if ( USE_FETCH_CONTENT ) set ( url https://github.com/alandefreitas/FetchBoostContent/blob/master/cmake/FetchBoostContent.cmake ) set ( destination ${ CMAKE_CURRENT_BINARY_DIR } /cmake/FetchBoostContent.cmake} ) if ( NOT EXISTS destination ) file ( DOWNLOAD ${ url } ${ destination } ) endif () include ( ${ destination } ) endif () This strategy might also be useful to keep the script up-to-date.","title":"Integration \ud83d\udcbb"},{"location":"quickstart/#hello-world","text":"Including the script include ( cmake/FetchBoostContent.cmake ) Declare and make available as target FetchBoostContent_Declare ( boost_circular_buffer GIT_REPOSITORY https://github.com/boostorg/circular_buffer GIT_TAG master ) FetchBoostContent_MakeAvailable ( boost_circular_buffer ) Declare content FetchBoostContent_Declare ( boost_beast GIT_REPOSITORY https://github.com/boostorg/beast GIT_TAG master ) Declare content # Check if population has already been performed FetchBoostContent_GetProperties ( boost_beast ) if ( NOT boost_beast_POPULATED ) # Fetch the content using previously declared details FetchBoostContent_Populate ( boost_beast ) Source directory include directories # Create an interface target for all the include dirs add_library ( boost_headers INTERFACE ) add_library ( Boost::headers ALIAS boost_headers ) # <library>_SOURCE_DIRS contains the source dir for all <library> dependencies foreach ( dir ${ boost_beast_SOURCE_DIRS } ) target_include_directories ( boost_headers INTERFACE ${ dir } /include ) endforeach () Linking interface target for all headers add_executable ( http-client-sync http-client-sync.cpp ) target_link_libraries ( http-client-sync Boost::headers ) Linking a compiled target add_executable ( container container.cpp ) target_link_libraries ( container Boost::container )","title":"Hello world \ud83d\udc4b"},{"location":"references/","text":"","title":"References"}]}